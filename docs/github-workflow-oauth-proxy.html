<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>GitHub Workflow with OAuth Proxy - Azure Resource Groups</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 650px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      color: #333;
      margin-bottom: 20px;
    }
    
    .workflow-section {
      background-color: #f5f5f5;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }
    
    .workflow-button {
      background-color: #2196F3;
      color: white;
      padding: 12px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 200px;
      margin: 20px 0;
      transition: background-color 0.3s;
      font-size: 16px;
      font-weight: bold;
    }
    
    .auth-button {
      background-color: #28a745;
    }
    
    .workflow-button.running {
      background-color: #FFC107;
      cursor: wait;
      position: relative;
    }
    
    .workflow-button.success {
      background-color: #4CAF50;
    }
    
    .workflow-button.failed {
      background-color: #F44336;
    }
    
    .workflow-button:hover {
      opacity: 0.9;
    }
    
    .workflow-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .workflow-button.running::after {
      content: "";
      position: absolute;
      bottom: 0;
      left: 0;
      height: 4px;
      width: 0%;
      background-color: rgba(255, 255, 255, 0.7);
      animation: progress 2s infinite linear;
    }
    
    @keyframes progress {
      0% { width: 0%; }
      100% { width: 100%; }
    }
    
    #workflow-status, #auth-status {
      margin-top: 15px;
      padding: 10px;
      min-height: 20px;
      border-radius: 4px;
      transition: all 0.3s;
    }
    
    .status-running {
      background-color: #FFF8E1;
      border-left: 4px solid #FFC107;
      padding-left: 10px;
    }
    
    .status-success {
      background-color: #E8F5E9;
      border-left: 4px solid #4CAF50;
      padding-left: 10px;
    }
    
    .status-failed {
      background-color: #FFEBEE;
      border-left: 4px solid #F44336;
      padding-left: 10px;
    }
    
    .workflow-logs {
      font-family: monospace;
      background-color: #263238;
      color: #ECEFF1;
      padding: 15px;
      border-radius: 4px;
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }
    
    .workflow-logs.show {
      display: block;
    }
    
    .log-entry {
      margin: 5px 0;
      line-height: 1.5;
    }
    
    .timestamp {
      color: #90A4AE;
    }
    
    .proxy-info {
      background-color: #e3f2fd;
      border-radius: 4px;
      padding: 15px;
      margin-bottom: 20px;
      border-left: 4px solid #2196F3;
    }
    
    .proxy-info h3 {
      margin-top: 0;
      color: #1976D2;
    }
    
    .hidden {
      display: none;
    }
  </style>
</head>

<body>  <h1>GitHub Workflow with OAuth Proxy</h1>

  <div class="workflow-section">
    <h2>Step 1: Authenticate with GitHub</h2>
    <p>Click the button below to authenticate with GitHub using OAuth.</p>
    <button id="auth-button" class="workflow-button auth-button">Authenticate with GitHub</button>
    <button id="logout-button" class="workflow-button" style="background-color: #607D8B; display: none; margin-top: 5px;">Log Out</button>
    <div id="auth-status"></div>
  </div>    <div class="workflow-section">
    <h2>Step 2: Trigger the Azure Resource Groups Workflow</h2>
    <p>After authenticating, you can trigger the GitHub workflow at <a href="https://github.com/mikestiers/workflows/actions/workflows/GetResourceGroups.yml" target="_blank">mikestiers/workflows/actions/workflows/GetResourceGroups.yml</a></p>
    
    <button id="workflow-trigger" class="workflow-button" disabled>Get Azure Resource Groups</button>    <div id="workflow-status"></div>
    <div id="workflow-logs" class="workflow-logs"></div>
  </div>
  <div class="workflow-section" id="resource-group-results" style="display: none;">
    <h2>üìã Azure Resource Group Results</h2>
    <div id="resource-group-count"></div>
    <div id="resource-group-list"></div>
    <div id="resource-group-data" style="margin-top: 15px;">
      <details>
        <summary style="cursor: pointer; font-weight: bold;">View Raw JSON Data</summary>
        <pre id="resource-group-json" style="background-color: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px;"></pre>
      </details>
    </div>
  </div>

  <div class="workflow-section">
    <h2>üîß Troubleshooting</h2>
    <details>
      <summary style="cursor: pointer; font-weight: bold;">Common Issues & Solutions</summary>
      <div style="margin-top: 10px;">        <h4>‚ùå "403 Forbidden" Error When Fetching Logs</h4>
        <p><strong>Cause:</strong> The GitHub token may not have sufficient permissions to read workflow logs.</p>
        <p><strong>Solutions:</strong></p>
        <ul>
          <li>Ensure your token has the <code>actions:read</code> scope</li>
          <li>For private repositories, ensure you have repository access</li>
          <li>The workflow logs may have expired (GitHub keeps them for 90 days)</li>
          <li>Use the artifacts download feature instead - data is always available there</li>
        </ul>
        
        <h4>üóúÔ∏è Compressed/Garbled Log Content</h4>
        <p><strong>Cause:</strong> GitHub Actions logs are often gzip compressed.</p>
        <p><strong>Solutions:</strong></p>
        <ul>
          <li>The page attempts automatic decompression for modern browsers</li>
          <li>If decompression fails, the complete data is available in artifacts</li>
          <li>Download artifacts for guaranteed access to readable data</li>
          <li>Artifacts contain both JSON and human-readable text formats</li>
        </ul>
        
        <h4>‚ö†Ô∏è No Resource Groups Displayed</h4>
        <p><strong>Cause:</strong> Log parsing failed or no resource groups exist.</p>
        <p><strong>Solutions:</strong></p>
        <ul>
          <li>Check the workflow logs manually on GitHub Actions page</li>
          <li>Download the artifacts which contain the complete data</li>
          <li>Verify your Azure credentials in the repository secrets</li>
          <li>Check if you have any resource groups in your Azure subscription</li>
        </ul>
        
        <h4>üîë Authentication Issues</h4>
        <p><strong>Solutions:</strong></p>
        <ul>
          <li>Re-authenticate with a fresh token</li>
          <li>Ensure the token has <code>workflow</code> and <code>actions:read</code> permissions</li>
          <li>Check that the repository is accessible with your account</li>
        </ul>
      </div>
    </details>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Configuration
      const PROXY_BASE_URL = 'https://github-oauth-proxy-2025.azurewebsites.net';      // GitHub repository details
      const repoOwner = 'mikestiers';
      const repoName = 'workflows';
      const workflowId = 'GetResourceGroups.yml';
        // Authentication state
      let accessToken = '';
      let authenticationInProgress = false;
      
      // Cache DOM elements
      const authButton = document.getElementById('auth-button');
      const logoutButton = document.getElementById('logout-button');
      const authStatus = document.getElementById('auth-status');
      
      const workflowButton = document.getElementById('workflow-trigger');
      const workflowStatus = document.getElementById('workflow-status');
      const workflowLogs = document.getElementById('workflow-logs');
      
      // Restore token from localStorage if available
      if (localStorage.getItem('github_token')) {
        accessToken = localStorage.getItem('github_token');
        authButton.textContent = 'Re-Authenticate with GitHub';
        logoutButton.style.display = 'block';
        workflowButton.disabled = false;
        appendAuthMessage('üîÑ Authentication restored from previous session', false);
        
        // Verify the token is still valid
        verifyTokenPermissions();
      }
      
      // Add event listeners
      authButton.addEventListener('click', startAuthentication);
      logoutButton.addEventListener('click', logOut);
      workflowButton.addEventListener('click', triggerWorkflow);      // Listen for OAuth callback messages
      window.addEventListener('message', handleOAuthMessage);
        /**
       * Handle OAuth callback messages from popup window
       */
      function handleOAuthMessage(event) {
        console.log('Received message:', event);
        console.log('Message origin:', event.origin);
        console.log('Expected origin:', PROXY_BASE_URL);
        console.log('Message data:', event.data);
        
        // Verify origin for security (but be more lenient for Azure)
        const expectedDomain = new URL(PROXY_BASE_URL).hostname;
        const actualDomain = new URL(event.origin).hostname;
        
        if (actualDomain !== expectedDomain) {
          console.warn('Message from unexpected origin, ignoring');
          console.warn('Expected domain:', expectedDomain, 'Actual domain:', actualDomain);
          return;
        }
          if (event.data.type === 'GITHUB_OAUTH_SUCCESS') {
          console.log('OAuth success message received');
          const token = event.data.access_token;
          appendAuthMessage('‚úÖ Received access token from popup', false);
          handleAuthenticationSuccess(token);
        } else if (event.data.type === 'GITHUB_OAUTH_ERROR') {
          console.log('OAuth error message received');
          appendAuthMessage(`‚ùå Authentication failed: ${event.data.error}`, true);
          authButton.disabled = false;
          authButton.textContent = 'Authenticate with GitHub';
        } else {
          console.log('Unknown message type:', event.data.type);
        }
      }
      
      /**
       * Start the GitHub OAuth flow via proxy
       */
      function startAuthentication() {
        // Prevent multiple clicks
        if (authButton.disabled) {
          return;
        }
        
        // Clear previous status
        authStatus.innerHTML = '';
        authStatus.className = '';
          // Update button state
        authButton.disabled = true;
        authButton.textContent = 'Opening GitHub...';
        authenticationInProgress = true;
          appendAuthMessage('üîÑ Initiating GitHub OAuth flow...', false);
        
        // Open OAuth popup
        const oauthUrl = `${PROXY_BASE_URL}/oauth/authorize`;
        const popup = window.open(
          oauthUrl, 
          'github_oauth', 
          'width=600,height=700,scrollbars=yes,resizable=yes'
        );
        
        if (!popup) {
          appendAuthMessage('‚ùå Popup blocked! Please allow popups and try again.', true);
          authButton.disabled = false;
          authButton.textContent = 'Authenticate with GitHub';
          return;
        }        appendAuthMessage('üîÑ Complete authentication in the popup window...', false);
        
        // Check if popup was closed without completing authentication
        const checkClosed = setInterval(() => {
          if (popup.closed && authenticationInProgress) {
            clearInterval(checkClosed);
            appendAuthMessage('‚ö†Ô∏è Authentication window was closed', false);
            authButton.disabled = false;
            authButton.textContent = 'Authenticate with GitHub';
            authenticationInProgress = false;
          }
        }, 1000);
      }
      
      /**
       * Handle successful authentication
       */      function handleAuthenticationSuccess(token) {
        console.log('üéâ Authentication successful, storing token');
        
        // Clear authentication state
        authenticationInProgress = false;
        
        // Store the access token
        accessToken = token;
        localStorage.setItem('github_token', accessToken);
        
        // Update UI
        authButton.disabled = false;
        authButton.textContent = 'Re-Authenticate with GitHub';
        logoutButton.style.display = 'block';
        workflowButton.disabled = false;
        
        // Clear previous messages and show success
        authStatus.innerHTML = '';
        appendAuthMessage('üéâ Authentication successful! You can now trigger workflows.', false);
        authStatus.className = 'status-success';
        
        // Verify token permissions
        verifyTokenPermissions();
      }
      
      /**
       * Log out by removing the stored token
       */
      function logOut() {
        localStorage.removeItem('github_token');
        accessToken = '';
        
        // Reset UI
        authButton.textContent = 'Authenticate with GitHub';
        logoutButton.style.display = 'none';
        workflowButton.disabled = true;
        
        // Clear status
        authStatus.innerHTML = '';
        authStatus.className = '';
        appendAuthMessage('‚úÖ Logged out successfully', false);
      }
      
      /**
       * Verify that the token has the required permissions
       */
      function verifyTokenPermissions() {
        // Check if the token is valid by getting user info via proxy
        fetch(`${PROXY_BASE_URL}/api/user`, {
          headers: {
            'Authorization': `token ${accessToken}`
          }
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`Authentication failed: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          if (data.login) {
            appendAuthMessage(`üë§ Authenticated as: ${data.login}`, false);
            
            // Now check if we can access the workflow endpoint
            return fetch(`${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/workflows`, {
              headers: {
                'Authorization': `token ${accessToken}`
              }
            });
          } else {
            throw new Error('Could not retrieve user information');
          }
        })
        .then(response => {
          if (!response.ok) {
            if (response.status === 403) {
              throw new Error('Your token does not have the workflow permission. Please re-authenticate.');
            }
            throw new Error(`Failed to access workflows: ${response.status}`);
          }
          return response.json();
        })        .then(data => {
          appendAuthMessage('‚úÖ Token verified with workflow access permissions.', false);
          appendAuthMessage('‚ö†Ô∏è Note: If you get "403 Forbidden" errors later, you may need additional permissions for private repositories or logs access.', false);
        })
        .catch(error => {
          console.error('Error verifying token:', error);
          appendAuthMessage(`‚ùå Error: ${error.message}`, true);
          
          if (error.message.includes('401') || error.message.includes('403')) {
            // Reset authentication state on error
            accessToken = '';
            localStorage.removeItem('github_token');
            
            // Update UI to allow re-authentication
            authButton.disabled = false;
            authButton.textContent = 'Authenticate with GitHub';
            logoutButton.style.display = 'none';
            workflowButton.disabled = true;
          }
        });
      }
      
      /**
       * Trigger the GitHub workflow via proxy
       */
      function triggerWorkflow() {
        const button = workflowButton;
        const statusEl = workflowStatus;
        const logsEl = workflowLogs;
        
        // Check if we have a token
        if (!accessToken) {
          appendLog('Error: No authentication token available', true);
          return;
        }
        
        // Prevent multiple clicks
        if (button.classList.contains('running')) {
          return;
        }
        
        // Clear previous state classes
        button.classList.remove('success', 'failed');
        statusEl.classList.remove('status-success', 'status-failed');
        statusEl.innerHTML = '';
        
        // Update button state to "running"
        button.classList.add('running');
        button.textContent = 'Running Workflow...';
        
        // Show status with running indicator
        const statusText = document.createElement('div');
        statusText.textContent = 'Workflow in progress. Please wait...';
        statusEl.appendChild(statusText);
        statusEl.classList.add('status-running');
        
        // Show logs panel
        logsEl.classList.add('show');
        logsEl.innerHTML = '';
        
        // Log initial action
        appendLog('Attempting to trigger GitHub workflow: ' + workflowId);
        appendLog(`Repository: ${repoOwner}/${repoName}`);
        
        // Call GitHub API via proxy to trigger the workflow
        triggerGitHubWorkflow()
          .then(data => {
            if (data.success) {
              handleWorkflowStarted(data);
              
              // Poll for workflow completion
              if (data.runId) {
                pollWorkflowStatus(data.runId);
              }
            } else {
              handleWorkflowFailed(data.error);
            }
          })
          .catch(error => {
            handleWorkflowFailed(error.message || 'Failed to trigger workflow');
          });
      }
      
      /**
       * Trigger the GitHub workflow via proxy API
       */
      async function triggerGitHubWorkflow() {
        try {
          appendLog('Dispatching workflow run request via proxy');
          
          // Make the API call via proxy to trigger the workflow
          const response = await fetch(`${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/workflows/${workflowId}/dispatches`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `token ${accessToken}`
            },
            body: JSON.stringify({
              ref: 'main', // or whatever branch you want to run the workflow on
              inputs: {} // Any input parameters your workflow accepts
            })
          });
          
          if (response.status === 204 || response.ok) {
            appendLog('Workflow dispatch received by GitHub');
            
            // Get the run ID by querying recent workflow runs
            const runsResponse = await fetch(`${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/workflows/${workflowId}/runs?per_page=1`, {
              headers: {
                'Authorization': `token ${accessToken}`
              }
            });
            
            if (!runsResponse.ok) {
              throw new Error(`GitHub API returned ${runsResponse.status}: ${await runsResponse.text()}`);
            }
            
            const runsData = await runsResponse.json();
            if (runsData.workflow_runs && runsData.workflow_runs.length > 0) {
              const runId = runsData.workflow_runs[0].id;
              appendLog(`Workflow run ID: ${runId}`);
              return {
                success: true,
                runId: runId,
                url: runsData.workflow_runs[0].html_url
              };
            }
            
            // If we couldn't get the run ID, still return success
            appendLog('Workflow triggered, but could not retrieve run ID');
            return { 
              success: true,
              url: `https://github.com/${repoOwner}/${repoName}/actions`
            };
          } else {
            let errorMessage = `GitHub API returned status ${response.status}`;
            try {
              const errorData = await response.json();
              errorMessage = errorData.message || errorMessage;
            } catch (e) {
              // Ignore JSON parsing errors
            }
            throw new Error(errorMessage);
          }
        } catch (error) {
          console.error('Error triggering workflow:', error);
          
          let errorMessage = error.message || 'Failed to trigger workflow';
          
          // Handle token expiration
          if (errorMessage.includes('Unauthorized') || errorMessage.includes('401')) {
            localStorage.removeItem('github_token');
            accessToken = '';
            workflowButton.disabled = true;
            errorMessage = 'Authentication expired or invalid. Please re-authenticate.';
          }
          
          return { 
            success: false, 
            error: errorMessage
          };
        }
      }
      
      /**
       * Handle successful workflow start
       */
      function handleWorkflowStarted(data) {
        appendLog('Workflow run started successfully');
        
        if (data.runId) {
          appendLog(`Run ID: ${data.runId}`);
        }
        
        if (data.url) {
          const runUrl = data.url;
          appendLog(`View run at: ${runUrl}`);
          
          // Add a link to the workflow run
          const linkContainer = document.createElement('div');
          linkContainer.style.marginTop = '10px';
          
          const link = document.createElement('a');
          link.href = runUrl;
          link.target = '_blank';
          link.textContent = 'Open Workflow Run';
          link.style.color = '#2196F3';
          
          linkContainer.appendChild(link);
          workflowStatus.appendChild(linkContainer);
        }
      }
        /**
       * Poll for workflow completion via proxy
       */
      function pollWorkflowStatus(runId) {
        appendLog('Checking workflow status...');
        
        // If we don't have a run ID, we can't poll for status
        if (!runId) {
          appendLog('No run ID available, cannot poll for status');
          appendLog('Please check GitHub Actions directly for workflow status');
          
          workflowButton.classList.remove('running');          workflowButton.textContent = 'Get Azure Resource Groups';
          
          workflowStatus.classList.remove('status-running');
          return;
        }
        
        let pollCount = 0;
        const maxPolls = 30; // Maximum number of status checks (with 2s delay = 1 minute max)
        
        // Function to check workflow status
        function checkStatus() {
          fetch(`${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/runs/${runId}`, {
            headers: {
              'Authorization': `token ${accessToken}`
            }
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`GitHub API returned ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            const status = data.status; // queued, in_progress, completed
            const conclusion = data.conclusion; // success, failure, cancelled, etc.
            
            appendLog(`Current status: ${status}${conclusion ? ', conclusion: ' + conclusion : ''}`);
            
            if (status === 'completed') {
              // Workflow has finished
              const success = conclusion === 'success';
                if (success) {
                // Update to success state
                appendLog('Workflow completed successfully!');
                
                workflowButton.classList.remove('running');
                workflowButton.classList.add('success');
                workflowButton.textContent = 'Workflow Completed';
                
                workflowStatus.classList.remove('status-running');
                workflowStatus.classList.add('status-success');
                
                const statusText = document.createElement('div');
                statusText.textContent = 'Workflow completed successfully!';
                workflowStatus.appendChild(statusText);
                  // Fetch and display resource group data
                fetchResourceGroupResults(runId);
                  // Reset button after 5 seconds
                setTimeout(function() {
                  workflowButton.classList.remove('success');
                  workflowButton.textContent = 'Get Azure Resource Groups';
                }, 5000);
              } else {
                // Update to failure state
                appendLog(`Workflow failed with conclusion: ${conclusion}`, true);
                
                workflowButton.classList.remove('running');
                workflowButton.classList.add('failed');
                workflowButton.textContent = 'Workflow Failed';
                
                workflowStatus.classList.remove('status-running');
                workflowStatus.classList.add('status-failed');
                  const statusText = document.createElement('div');
                statusText.textContent = `Workflow failed with conclusion: ${conclusion}`;
                workflowStatus.appendChild(statusText);
                  // Reset button after 5 seconds
                setTimeout(function() {
                  workflowButton.classList.remove('failed');
                  workflowButton.textContent = 'Get Azure Resource Groups';
                }, 5000);
              }
              
              // Workflow is complete, no need to poll again
              return;            } else if (pollCount >= maxPolls) {
              // We've polled too many times, stop polling
              appendLog('Exceeded maximum polling attempts. Please check GitHub directly for status.', true);
                // Reset button
              workflowButton.classList.remove('running');
              workflowButton.textContent = 'Get Azure Resource Groups';
              return;
            }
            
            // Continue polling
            pollCount++;
            setTimeout(checkStatus, 2000); // Poll every 2 seconds
          })          .catch(error => {
            appendLog(`Error checking workflow status: ${error.message}`, true);
              // On error, stop polling and reset the button
            workflowButton.classList.remove('running');
            workflowButton.textContent = 'Get Azure Resource Groups';
          });
        }
        
        // Start polling
        checkStatus();
      }
      
      /**
       * Handle workflow failure
       */
      function handleWorkflowFailed(errorMessage) {
        appendLog(`Error: ${errorMessage}`, true);
        
        workflowButton.classList.remove('running');
        workflowButton.classList.add('failed');
        workflowButton.textContent = 'Workflow Failed';
        
        workflowStatus.classList.remove('status-running');
        workflowStatus.classList.add('status-failed');
        
        const statusText = document.createElement('div');
        statusText.textContent = `Failed to trigger workflow: ${errorMessage}`;
        workflowStatus.innerHTML = '';
        workflowStatus.appendChild(statusText);          // Reset button after 5 seconds
        setTimeout(function() {
          workflowButton.classList.remove('failed');
          workflowButton.textContent = 'Get Azure Resource Groups';
          workflowStatus.classList.remove('status-failed');
          workflowStatus.innerHTML = '';
        }, 5000);
      }
      
      /**
       * Append an authentication message to the auth status element
       */
      function appendAuthMessage(message, isError) {
        const messageEl = document.createElement('div');
        messageEl.textContent = message;
        messageEl.style.padding = '5px 0';
        messageEl.style.lineHeight = '1.4';
        
        if (isError) {
          messageEl.style.color = '#F44336';
          messageEl.style.fontWeight = 'bold';
        } else if (message.includes('‚úÖ') || message.includes('üéâ')) {
          messageEl.style.color = '#28a745';
          messageEl.style.fontWeight = 'bold';
        } else if (message.includes('üîÑ') || message.includes('‚è≥')) {
          messageEl.style.color = '#FFC107';
        }
        
        authStatus.appendChild(messageEl);
      }
      
      /**
       * Append a log entry with timestamp to the logs panel
       */
      function appendLog(message, isError = false) {
        const now = new Date();
        const timestamp = now.toLocaleTimeString();
        
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        
        const timeSpan = document.createElement('span');
        timeSpan.className = 'timestamp';
        timeSpan.textContent = `[${timestamp}] `;
        
        logEntry.appendChild(timeSpan);
        
        const messageText = document.createTextNode(message);
        logEntry.appendChild(messageText);
        
        if (isError) {
          logEntry.style.color = '#FF8A80';
        }
        
        workflowLogs.appendChild(logEntry);
        workflowLogs.scrollTop = workflowLogs.scrollHeight;
      }
        /**
       * Fetch resource group results from the completed workflow
       */
      async function fetchResourceGroupResults(runId) {
        try {
          appendLog('üîç Fetching resource group results from workflow...');
          
          // Get job details to access outputs
          const jobsResponse = await fetch(`${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/runs/${runId}/jobs`, {
            headers: {
              'Authorization': `token ${accessToken}`
            }
          });
          
          if (!jobsResponse.ok) {
            throw new Error(`Failed to fetch job details: ${jobsResponse.status}`);
          }
          
          const jobsData = await jobsResponse.json();
          appendLog(`üìã Found ${jobsData.jobs.length} job(s)`);
          
          // Find the get-resource-groups job
          const resourceGroupJob = jobsData.jobs.find(job => job.name === 'Get Azure Resource Groups');
          
          if (!resourceGroupJob) {
            appendLog('‚ö†Ô∏è Could not find resource group job in workflow run', true);
            return;
          }
          
          appendLog(`‚úÖ Found resource group job with status: ${resourceGroupJob.status}`);
            // Get workflow run details to access outputs
          const runResponse = await fetch(`${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/runs/${runId}`, {
            headers: {
              'Authorization': `token ${accessToken}`
            }
          });
          
          if (!runResponse.ok) {
            throw new Error(`Failed to fetch run details: ${runResponse.status}`);
          }
          
          const runData = await runResponse.json();
            // Check if we can access job outputs
          if (runData.conclusion === 'success') {
            appendLog('üîç Checking for resource group data...');
            
            // GitHub Actions job outputs are not directly accessible from run API
            // The outputs defined in the workflow are internal to GitHub Actions
            // We need to parse the logs to extract the data
            appendLog('üìù Job outputs are not accessible via API, proceeding to log parsing');
          }
            // Try to get artifacts which contain the resource group data
          const artifactsResponse = await fetch(`${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/runs/${runId}/artifacts`, {
            headers: {
              'Authorization': `token ${accessToken}`
            }
          });
          
          if (artifactsResponse.ok) {
            const artifactsData = await artifactsResponse.json();
            const resourceGroupArtifact = artifactsData.artifacts.find(artifact => 
              artifact.name.includes('azure-resource-groups')
            );
              if (resourceGroupArtifact) {
              appendLog(`üì¶ Found resource group artifact: ${resourceGroupArtifact.name}`);
              displayResourceGroupArtifactInfo(resourceGroupArtifact);
              
              // Since artifacts contain the complete data, let's show a message about this
              appendLog('‚úÖ Complete resource group data is available in the artifact above');
              appendLog('üí° Artifact contains both JSON and text format data');
              
              // Create a mock display to show that data is available
              const mockDisplayData = [{
                name: 'Resource groups available in artifact',
                location: 'Download from link above',
                state: 'Data available'
              }];
              displayResourceGroupResults(mockDisplayData, 1, null);
            } else {
              appendLog('‚ö†Ô∏è No resource group artifacts found');
            }
          }          // Parse logs for resource group information (fallback method)
          appendLog('üîÑ Attempting to fetch workflow logs...');
          
          // Try different approaches to get the logs
          const logEndpoints = [
            // Try job logs first
            `${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/jobs/${resourceGroupJob.id}/logs`,
            // Try workflow run logs as backup
            `${PROXY_BASE_URL}/api/repos/${repoOwner}/${repoName}/actions/runs/${runId}/logs`
          ];
          
          let logsText = null;
          let logsFetched = false;
          
          for (const endpoint of logEndpoints) {
            try {
              appendLog(`üìù Trying logs endpoint: ${endpoint.split('/').slice(-2).join('/')}`);
                const logsResponse = await fetch(endpoint, {
                headers: {
                  'Authorization': `token ${accessToken}`,
                  'Accept': 'application/vnd.github.v3+json'
                }
              });
              
              if (logsResponse.ok) {
                // GitHub Actions logs are often gzip compressed
                const contentEncoding = logsResponse.headers.get('content-encoding');
                appendLog(`üìù Content encoding: ${contentEncoding || 'none'}`);
                
                // Get the response as array buffer to handle potential compression
                const arrayBuffer = await logsResponse.arrayBuffer();
                
                let logsTextTemp;
                if (contentEncoding === 'gzip' || endpoint.includes('/logs')) {
                  // Try to decompress if it's gzip or if it's a logs endpoint
                  try {
                    // Check if the data looks like gzip (starts with 0x1f 0x8b)
                    const uint8Array = new Uint8Array(arrayBuffer);
                    if (uint8Array[0] === 0x1f && uint8Array[1] === 0x8b) {
                      appendLog('üìù Detected gzip compressed logs, attempting to decompress...');
                      
                      // Try to use DecompressionStream if available (modern browsers)
                      if (typeof DecompressionStream !== 'undefined') {
                        const decompressedStream = new DecompressionStream('gzip');
                        const response = new Response(arrayBuffer);
                        const decompressedResponse = response.body.pipeThrough(decompressedStream);
                        const decompressedBuffer = await new Response(decompressedResponse).arrayBuffer();
                        logsTextTemp = new TextDecoder().decode(decompressedBuffer);
                        appendLog('üìù Successfully decompressed logs using DecompressionStream');
                      } else {
                        appendLog('‚ö†Ô∏è Browser does not support DecompressionStream, trying alternative...');
                        // Fallback: try to decode as text anyway (might work for some logs)
                        logsTextTemp = new TextDecoder('utf-8', { ignoreBOM: true }).decode(arrayBuffer);
                      }
                    } else {
                      // Not gzip, decode as regular text
                      logsTextTemp = new TextDecoder().decode(arrayBuffer);
                    }
                  } catch (decompressionError) {
                    appendLog(`‚ö†Ô∏è Decompression failed: ${decompressionError.message}`);
                    // Fallback to regular text decoding
                    logsTextTemp = new TextDecoder('utf-8', { ignoreBOM: true }).decode(arrayBuffer);
                  }
                } else {
                  // Regular text response
                  logsTextTemp = new TextDecoder().decode(arrayBuffer);
                }
                
                // Check if the logs look reasonable (not binary garbage)
                const isValidText = /^[\x20-\x7E\s]*$/.test(logsTextTemp.substring(0, 500));
                if (!isValidText && logsTextTemp.length > 100) {
                  appendLog('‚ö†Ô∏è Logs appear to be compressed/binary, but decompression failed');
                  appendLog('üí° Try downloading the logs manually from GitHub Actions page');
                  continue; // Try next endpoint
                }
                
                logsText = logsTextTemp;
                appendLog('üìù Successfully fetched workflow logs');
                appendLog(`üìÑ Log size: ${logsText.length} characters`);
                logsFetched = true;
                break;
              } else if (logsResponse.status === 403) {
                appendLog(`‚ùå Access denied (403) for ${endpoint.split('/').slice(-2).join('/')}`);
                appendLog('‚ö†Ô∏è This may be due to insufficient token permissions or private repository settings');
              } else {
                appendLog(`‚ùå Failed to fetch from ${endpoint.split('/').slice(-2).join('/')} (status: ${logsResponse.status})`);
              }
              
            } catch (error) {
              appendLog(`‚ùå Error fetching from ${endpoint.split('/').slice(-2).join('/')}: ${error.message}`);
            }
          }
          
          if (logsFetched && logsText) {
            // Show a sample of the logs for debugging
            const logLines = logsText.split('\n');
            appendLog(`üìÑ Total log lines: ${logLines.length}`);
            
            // Show first few lines that contain relevant information
            const relevantLines = logLines.filter(line => 
              line.includes('resource group') || 
              line.includes('Found') ||
              line.includes('[') ||
              line.includes('- ') ||
              line.includes('azure') ||
              line.includes('group list')
            ).slice(0, 5);
            
            if (relevantLines.length > 0) {
              appendLog(`üìÑ Sample relevant log lines:`);
              relevantLines.forEach((line, idx) => {
                appendLog(`  ${idx + 1}: ${line.trim()}`);
              });
            }
            
            parseResourceGroupLogs(logsText);
          } else {
            appendLog('‚ùå Could not access workflow logs from any endpoint', true);
            appendLog('üí° This might be due to one of the following reasons:');
            appendLog('   ‚Ä¢ Token needs "actions:read" permission scope');
            appendLog('   ‚Ä¢ Repository is private and token lacks access');
            appendLog('   ‚Ä¢ Workflow logs have expired or been deleted');
            appendLog('');
            appendLog('üì¶ Alternative: Resource group data is available in workflow artifacts');
            appendLog('üîó You can download the artifacts from the GitHub Actions page');
            
            // Show a helpful message in the UI even if we can't parse logs
            const mockResourceGroups = [{
              name: 'Unable to fetch logs',
              location: 'Check artifacts',
              state: 'Permission denied'
            }];
            displayResourceGroupResults(mockResourceGroups, 0, null);
          }
          
        } catch (error) {
          console.error('Error fetching resource group results:', error);
          appendLog(`‚ùå Error fetching resource group results: ${error.message}`, true);
        }
      }      /**
       * Parse workflow logs to extract resource group information
       */
      function parseResourceGroupLogs(logsText) {
        try {
          appendLog('üìù Parsing workflow logs for resource group data...');
          
          const lines = logsText.split('\n');
          let resourceGroupCount = 0;
          let resourceGroups = [];
          let jsonData = null;
          let currentJsonBuffer = '';
          let insideJsonBlock = false;
          
          // Look for resource group information in the logs
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Look for resource group count
            if (line.includes('Found') && line.includes('resource group(s)')) {
              const match = line.match(/Found (\d+) resource group\(s\)/);
              if (match) {
                resourceGroupCount = parseInt(match[1]);
                appendLog(`üìä Parsed count: ${resourceGroupCount}`);
              }
            }
            
            // Look for start of JSON array
            if (line.startsWith('[') && line.includes('"name"')) {
              insideJsonBlock = true;
              currentJsonBuffer = line;
              
              // Check if it's a single line JSON
              if (line.endsWith(']')) {
                try {
                  jsonData = JSON.parse(currentJsonBuffer);
                  if (Array.isArray(jsonData)) {
                    resourceGroups = jsonData;
                    appendLog(`üìã Parsed ${resourceGroups.length} resource groups from single-line JSON`);
                  }
                  insideJsonBlock = false;
                  currentJsonBuffer = '';
                } catch (e) {
                  // Continue collecting lines
                }
              }
              continue;
            }
            
            // Continue collecting multi-line JSON
            if (insideJsonBlock) {
              currentJsonBuffer += '\n' + line;
              
              if (line.endsWith(']')) {
                try {
                  jsonData = JSON.parse(currentJsonBuffer);
                  if (Array.isArray(jsonData)) {
                    resourceGroups = jsonData;
                    appendLog(`üìã Parsed ${resourceGroups.length} resource groups from multi-line JSON`);
                  }
                } catch (e) {
                  appendLog(`‚ö†Ô∏è Failed to parse JSON block: ${e.message}`);
                }
                insideJsonBlock = false;
                currentJsonBuffer = '';
              }
              continue;
            }
            
            // Look for single JSON object
            if (line.startsWith('{') && line.includes('"name"') && line.endsWith('}')) {
              try {
                const singleRg = JSON.parse(line);
                if (singleRg.name) {
                  resourceGroups.push(singleRg);
                  appendLog(`üìù Parsed single resource group: ${singleRg.name}`);
                }
              } catch (e) {
                // Ignore JSON parse errors for single objects
              }
            }
            
            // Look for human-readable resource group entries (lines starting with "- ")
            if (line.startsWith('- ') && line.includes('(') && line.includes(')')) {
              const match = line.match(/^- (.+) \(([^)]+)\) - (.+)$/);
              if (match) {
                const rgName = match[1].trim();
                const rgLocation = match[2].trim();
                const rgState = match[3].trim();
                
                resourceGroups.push({
                  name: rgName,
                  location: rgLocation,
                  state: rgState
                });
                appendLog(`üìù Parsed resource group: ${rgName} in ${rgLocation}`);
              }
            }
          }
          
          // Remove duplicates based on name
          const uniqueResourceGroups = [];
          const seenNames = new Set();
          
          resourceGroups.forEach(rg => {
            if (rg.name && !seenNames.has(rg.name)) {
              seenNames.add(rg.name);
              uniqueResourceGroups.push(rg);
            }
          });
          
          appendLog(`üìä Total unique resource groups parsed: ${uniqueResourceGroups.length}`);
          
          // Display the results
          if (resourceGroupCount > 0 || uniqueResourceGroups.length > 0) {
            displayResourceGroupResults(uniqueResourceGroups, resourceGroupCount || uniqueResourceGroups.length, jsonData);
          } else {
            appendLog('‚ö†Ô∏è No resource group data found in logs');
            appendLog('üí° Check the workflow logs manually for resource group information');
          }
          
        } catch (error) {
          appendLog(`‚ùå Error parsing logs: ${error.message}`, true);
        }
      }      /**
       * Display resource group results in the UI
       */
      function displayResourceGroupResults(resourceGroups, count, jsonData) {
        appendLog(`üìä Displaying results for ${resourceGroups.length} resource group(s)`);
        
        // Show the results section
        const resultsSection = document.getElementById('resource-group-results');
        resultsSection.style.display = 'block';
        
        // Update count
        const countElement = document.getElementById('resource-group-count');
        const finalCount = count || resourceGroups.length;
        countElement.innerHTML = `<h3>Total Resource Groups Found: ${finalCount}</h3>`;
        
        // Display resource group list
        const listElement = document.getElementById('resource-group-list');
        if (resourceGroups.length > 0) {
          let listHtml = '<h4>Resource Group Details:</h4><ul style="list-style-type: none; padding-left: 0;">';
          
          resourceGroups.forEach((rg, index) => {
            const name = rg.name || 'Unknown';
            const location = rg.location || rg.properties?.location || 'Unknown';
            const state = rg.state || rg.properties?.provisioningState || 'Unknown';
            const id = rg.id || 'N/A';
            
            listHtml += `<li style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">`;
            listHtml += `<strong style="font-size: 16px; color: #2196F3;">${name}</strong>`;
            
            if (location !== 'Unknown') {
              listHtml += ` <span style="background-color: #e3f2fd; padding: 2px 6px; border-radius: 3px; font-size: 12px; margin-left: 10px;">${location}</span>`;
            }
            
            if (state !== 'Unknown') {
              const stateColor = state === 'Succeeded' ? '#4CAF50' : (state === 'Failed' ? '#F44336' : '#FF9800');
              listHtml += ` <span style="background-color: ${stateColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 12px; margin-left: 5px;">${state}</span>`;
            }
            
            if (id && id !== 'N/A' && id.length > 10) {
              listHtml += `<br><small style="color: #666; font-family: monospace; font-size: 11px; margin-top: 5px; display: block;">${id}</small>`;
            }
            
            listHtml += '</li>';
          });
          
          listHtml += '</ul>';
          listElement.innerHTML = listHtml;
        } else {
          listElement.innerHTML = '<p style="color: #666;">No resource group details available</p>';
        }
        
        // Display raw JSON data
        const jsonElement = document.getElementById('resource-group-json');
        if (jsonData && Array.isArray(jsonData)) {
          jsonElement.textContent = JSON.stringify(jsonData, null, 2);
        } else if (resourceGroups.length > 0) {
          jsonElement.textContent = JSON.stringify(resourceGroups, null, 2);
        } else {
          jsonElement.textContent = 'No JSON data available';
        }
        
        // Scroll to results
        resultsSection.scrollIntoView({ behavior: 'smooth' });
        
        appendLog(`‚úÖ Resource group results displayed successfully`);
      }      /**
       * Display artifact information
       */
      function displayResourceGroupArtifactInfo(artifact) {
        appendLog(`üì¶ Artifact available: ${artifact.name}`);
        appendLog(`üìÖ Created: ${new Date(artifact.created_at).toLocaleString()}`);
        appendLog(`üíæ Size: ${(artifact.size_in_bytes / 1024).toFixed(2)} KB`);
        
        // Show the results section and add prominent artifact info
        const resultsSection = document.getElementById('resource-group-results');
        resultsSection.style.display = 'block';
        
        // Update the count section to show artifact info
        const countElement = document.getElementById('resource-group-count');
        countElement.innerHTML = `
          <h3>üì¶ Azure Resource Group Data Available in Artifacts</h3>
          <div style="background-color: #e8f5e9; padding: 15px; border-radius: 8px; border-left: 4px solid #4caf50; margin: 10px 0;">
            <h4 style="margin-top: 0; color: #2e7d32;">‚úÖ Complete Data Available for Download</h4>
            <p><strong>Artifact Name:</strong> ${artifact.name}</p>
            <p><strong>File Size:</strong> ${(artifact.size_in_bytes / 1024).toFixed(2)} KB</p>
            <p><strong>Created:</strong> ${new Date(artifact.created_at).toLocaleString()}</p>
            <p><strong>Contains:</strong> JSON data and human-readable text format</p>
          </div>
        `;
        
        // Add download instructions
        const listElement = document.getElementById('resource-group-list');
        listElement.innerHTML = `
          <h4>üì• How to Download Resource Group Data:</h4>
          <div style="background-color: #f3f4f6; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <ol style="margin: 0; padding-left: 20px;">
              <li>Click the <strong>"Open Workflow Run"</strong> link above</li>
              <li>Scroll down to the <strong>"Artifacts"</strong> section on the GitHub page</li>
              <li>Click on <strong>"${artifact.name}"</strong> to download the ZIP file</li>
              <li>Extract the ZIP to find:
                <ul style="margin-top: 5px;">
                  <li><code>resource-groups.json</code> - Complete JSON data</li>
                  <li><code>resource-groups.txt</code> - Human-readable format</li>
                </ul>
              </li>
            </ol>
            <p style="margin-top: 10px; color: #666; font-size: 14px;">
              üí° <strong>Tip:</strong> The JSON file contains complete resource group information including IDs, properties, and metadata.
            </p>
          </div>
        `;
        
        // Show artifact info in JSON section too
        const jsonElement = document.getElementById('resource-group-json');
        jsonElement.textContent = `Artifact Information:
Name: ${artifact.name}
Size: ${(artifact.size_in_bytes / 1024).toFixed(2)} KB
Created: ${new Date(artifact.created_at).toLocaleString()}
Download URL: Available on GitHub Actions page

The complete resource group data is available in the downloadable artifact above.
This includes both JSON format and human-readable text format.`;
        
        // Scroll to results
        resultsSection.scrollIntoView({ behavior: 'smooth' });
      }
    });
  </script>
</body>

</html>
